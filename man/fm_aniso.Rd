% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/matern.R
\name{fm_aniso}
\alias{fm_aniso}
\alias{fm_aniso_precision}
\alias{fm_aniso_sample}
\alias{fm_aniso_basis_weights_sample}
\title{Anisotropic field methods}
\usage{
fm_aniso_precision(x, aniso, log_sigma = 0)

fm_aniso_sample(x, aniso, n = 1, loc = NULL)

fm_aniso_basis_weights_sample(x, aniso, n = 1, log_sigma = 0)
}
\arguments{
\item{x}{A 2d mesh object.}

\item{aniso}{List \verb{[kappa,vec]} where \code{kappa} controls the (inverse) correlation range
and (the half angle version of) \code{vec} controls the main directions of the anisotropy.}

\item{log_sigma}{The logarithmm of the marginal variance sigma (is a constant)}

\item{n}{Number of samples (default=1).}

\item{loc}{locations to evaluate the random field, compatible with
\code{fm_evaluate(x, loc = loc, field = ...)}}
}
\value{
\code{fm_aniso_sample()} returns a matrix, where each column is a sampled
field. If \code{loc} is \code{NULL}, the \code{fm_dof(mesh)} basis weights are given.
Otherwise, the evaluated field at the \code{nrow(loc)} locations \code{loc} are given.

\code{fm_aniso_sample()} returns a vector whose j_th component is a sample of the
weight u_j of the jth basis vector.
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}
Methods for anisotropic SPDEs and GMRFs.
}
\section{Functions}{
\itemize{
\item \code{fm_aniso_precision()}: Construct the (sparse) precision matrix for the basis weights of anisotropic
SPDE models.

\item \code{fm_aniso_sample()}: Simulate an anisotropic field given a mesh and
anisotropic parameters, and optionally evaluate at given locations.

\item \code{fm_aniso_basis_weights_sample()}: Simulates the basis weights u_i in \eqn{u(x) = \sum(u_j \phi_j(x))}{u(x) = sum(u_j phi_j(x))}

}}
\examples{
mesh <- fm_mesh_2d_inla(boundary = fm_extensions(cbind(2, 1), convex = 1, 2))
kappa <- 1
v <- c(1, 2)
aniso <- list(rep(kappa, mesh$n), matrix(v, mesh$n, 2))
Q <- fm_aniso_precision(mesh, aniso)
}
